# Circuit-tracing


Алгоритм состоит из 2 шагов
* Рисуем кратчайшие дорожки на одном слое
* Раскидываем пересекающиеся дорожки по разным слоям

### Первый шаг
Кратчайшие дорожки ищем [волновым алгоритмом Ли](https://ru.wikipedia.org/wiki/%D0%90%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC_%D0%9B%D0%B8) (по сути это тупо обход в ширину)

1)Волновой алгоритм работает на поле с клетками. Поэтому сначала мы представим на нашем слое сетку с шагом 0.1 мм (т.е. каждая клеточка имеет сторону 0.1 мм) 
По сути клеточки этой сетки и будут нашими полигонами на выходе.

2)Для каждой пары пинов находим кратчайший путь. Путь запоминаем. Также, для каждого пути запоминаем, с которыми путями он пересекается.
Первый шаг закончен, мы построили на первом слое кучу путей для всех пинов, причём все пути кратчайшие

Важный момент: минимальное расстояние между дорожками = 0.1 мм => когда волновым алгоритмом заполняем клеточки, то все соседние тоже считаем занятыми
 
### Второй шаг
3)Теперь строим граф пересечений G - это такой граф, у которого каждая вершина соответствует дорожке, а рёбра соответствуют пересечениям дорожек (т.е. если дорожки пересекаются, то соответствующие им вершины в графе G соединены ребром)

4)Красим G в минимальное число цветов так, чтобы соседние вершины имели разный цвет.
Тут можно пока использовать жадный алгоритм, но он может иногда давать очень плохие результаты, поэтому если останетсся время, то стоит поискать что-то более оптимальное

5) все вершины одного цвета - это дорожки, которые не пересекаются, их можно оставить на одном слое. 
То есть теперь мы раскидываем по слоям:
Выберем первый цвет, все дорожки этого цвета оставляем на втором шаге.
выбераем 2 цвет, ставим пару полигонов на первом слое, потом переходим на 2 слой и дорисовываем там кроме последних 2 полигонов, переходим на 1 слой (два первых и последих полигона остаются на первом слое по той причине, что переход нельзя делать на месте пина, а так как диаметр пина 0.2 mm а длина полигона 0.1 mm, то мы сначала выходим за пределы пина, а потом переходим на другой слой)

6) вывод данных


есть пара моментов, в которых я сомневаюсь.

1) считаются ли 2 соседние клетки пересекающимися полигонами?

2) Возможно, идущие подряд полигоны нужно обьединять, т.к. длина линии считается как сумма полупериметров всех полигонов => чем меньше полигонов тем меньше периметр, а у нас полигонов оч много. 

пример: на картинке в первом случае линия из двух полигонов имеет длину равную 4 (т.к. сумма периметров полигонов 8), а во втором 3 

![картинка](http://cs628525.vk.me/v628525472/4a419/Oaff2fyRV2k.jpg)


### Предположение по 2 пункту
Принципиально важно использовать минимальное количество слоёв. Вместо поиска покрытия лучше найти набор непересекающихся соединений, у которого отношение = (суммарная длина соединений) / (количество соединений) будет минимальным. 
Далее, по волновому алгоритму найти из оставшихся соединений аналогичный набор и нанести на этой же слой.
А потом переход на следующий слой. У пинов делать дырки
Далее, найти такой же набор из оставшихся. 

